
import java.io.File;
import java.io.OutputStream;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * 
 * 将数据导出为建库脚本
 * 
 * @author xiatian
 */
@SuppressWarnings({"rawtypes","unchecked"})
public class DB2sql{
	
	private static String path = "./";
	public static boolean useText = false;

	public static String dumpDB(Properties props) {
		String driverClassName = props.getProperty("driver.class");
		String driverURL = props.getProperty("driver.url");
		String catalogName = props.getProperty("user");
		String outCatalogName = null;
		// 启用高速，则数据写入固态硬盘，完事后移动到移动硬盘上
		boolean bUseGs = false;
		File f1 = new File(outCatalogName = path + catalogName + ".sql");
		if (f1.exists()) {
			f1.delete();
			// return "";
			// f1.renameTo(new File(path + catalogName +
			// "_" + System.nanoTime() + ".sql"));
		}
		outCatalogName = path + catalogName + ".sql";
		OutputStream bos = null;
		if (bUseGs) {
			outCatalogName = "data/" + catalogName + ".sql";
			f1 = new File(outCatalogName);
		}
		// Default to not having a quote character
		String columnNameQuote = props.getProperty("columnName.quoteChar", "");
		DatabaseMetaData dbMetaData = null;
		Connection dbConn = null;
		try {
			Class.forName(driverClassName);
			props.setProperty("remarksReporting","true");  
			dbConn = DriverManager.getConnection(driverURL, props);
			dbMetaData = dbConn.getMetaData();
		} catch (Exception e) {
			InfoLog.info("无法连接：", driverURL, " ", catalogName);
			System.err.println("Unable to connect to database: " + e);
			return null;
		}
		ResultSet rs = null;
		ResultSet primaryKeys = null;
		ResultSet tableMetaData = null;
		StringBuffer result = new StringBuffer(), resultTb = new StringBuffer();
		try {
			//获取查询导出数据库对象的条件
			String catalog = null;
			String schema = null;
			String tables = null;
			String types[] = null;
			if(props.getProperty("catalog") != ""){
				catalog = props.getProperty("catalog");
			}
			if(props.getProperty("schemaPattern") != ""){
				schema = props.getProperty("schemaPattern");
			}
			if(dbConn.getClass().getName().toUpperCase().indexOf("SQLSERVER") > -1){
				schema = "dbo";
			}
			if(props.getProperty("tableName") != ""){
				tables = props.getProperty("tableName");
			}
			if(props.getProperty("type") != ""){
				types = props.getProperty("type").split(",");
			}
			//查询需要导出时间的数据库对象
			rs = dbMetaData.getTables(catalog, schema, tables, types);
			if (!rs.next()) {
				System.err.println("根据参数: catalog=" + catalog + " schema=" + schema + " tables="
								+ tables + "没有找到任何符合要求的对象");
				rs.close();
			} else {
				outCatalogName = path + catalogName + ".sql";
				f1 = new File(outCatalogName);
				if (f1.exists())
					return "";
				InfoLog.info("开始处理", outCatalogName);
				StringBuffer exptables = new StringBuffer("");
				do {
					String tableName = rs.getString("TABLE_NAME");//当前查询出的table名称
					String tableDesc = rs.getString("REMARKS");//当前查询出的table注释
					String tablesname = props.getProperty("tablesname").toUpperCase();//获取需要导出数据的对象名称
					if (tablesname.indexOf(tableName.toUpperCase()) < 0 || exptables.indexOf(tableName) > -1) {
						continue;
					}
					String tableType = rs.getString("TABLE_TYPE");
					if ("TABLE".equalsIgnoreCase(tableType)) {
						
						{
							//如果是oracle
							if(dbConn.getClass().getName().toUpperCase().indexOf("ORACLE") > -1){
								result.append("\ndeclare \n num number; \nbegin "
										+ "\n SELECT count(1) INTO num from ALL_TABLES WHERE TABLE_NAME = '" + tableName.toUpperCase() + "' and "
										+ "OWNER = '" + catalogName.toUpperCase() + "';\n  IF num = 1 THEN \n "
										+ "  EXECUTE IMMEDIATE 'DROP TABLE " + tableName.toUpperCase() + "';\n END IF;\n"
										+ "END;\n/");
							}else if(dbConn.getClass().getName().toUpperCase().indexOf("SQLSERVER") > -1){//如果是sqlserver
								result.append("\nIF OBJECT_ID('" + tableName.toUpperCase() + "') IS NOT NULL DROP TABLE "+ tableName.toUpperCase() + "\nGO");
							}else if(dbConn.getClass().getName().toUpperCase().indexOf("MYSQL") > -1){
								result.append("\nDROP TABLE IF EXISTS "+tableName+";");
							}
							result.append("\n-- " + tableName);
							result.append("\nCREATE TABLE " + tableName+ " (\n");
						}
						try {
							// java.sql.SQLException: ORA-01424: 转义符之后字符缺失或非法
							// http://www.iteye.com/problems/55630
							if (tableName.contains("/")
									|| tableName.contains("$")
									|| tableName.contains("=")
									|| tableName.contains("BIN")) {
								continue;
								// tableName = "\"" + tableName + "\"";
							}
							tableMetaData = dbMetaData.getColumns(null, null,
									tableName, "%");
							boolean firstLine = true;
							StringBuffer columnNmaes = new StringBuffer("");
							while (tableMetaData.next()) {
								String columnName = tableMetaData.getString("COLUMN_NAME");
								String columnType = tableMetaData.getString("TYPE_NAME");
								String columnDesc = tableMetaData.getString("REMARKS");
								if(columnNmaes.indexOf(columnName) > -1 )
									continue;

								if (firstLine) {
									firstLine = false;
								} else {
									result.append(",\n");
								}
								// WARNING: this may give daft answers for some
								// types on some databases (eg JDBC-ODBC link)
								int columnSize = tableMetaData.getInt("COLUMN_SIZE");
								String nullable = tableMetaData.getString("IS_NULLABLE");
								String nullString = "";
								if ("NO".equalsIgnoreCase(nullable)) {
									nullString = "NOT NULL";
								}
								if(columnType.equals("DATE") || columnType.equals("NUMBER") ){
									result.append("    " + columnNameQuote
											+ columnName + columnNameQuote + " "
											+ columnType);
								}else{
									result.append("    " + columnNameQuote
											+ columnName + columnNameQuote + " "
											+ columnType + " (" + columnSize + ")"
											+ " " + nullString);
								}
								if(dbConn.getClass().getName().toUpperCase().indexOf("MYSQL") > -1 && columnDesc != null && columnDesc != ""){
									result.append(" COMMENT'"+columnDesc + "'");
								}
								columnNmaes.append(columnName);
							}
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							try {
								if (null != tableMetaData)
									tableMetaData.close();
								tableMetaData = null;
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
						// Now we need to put the primary key constraint
						try {
							primaryKeys = dbMetaData.getPrimaryKeys(catalog,schema, tableName);
							// What we might get:
							// TABLE_CAT String => table catalog (may be null)
							// TABLE_SCHEM String => table schema (may be null)
							// TABLE_NAME String => table name
							// COLUMN_NAME String => column name
							// KEY_SEQ short => sequence number within primary
							// key
							// PK_NAME String => primary key name (may be null)
							String primaryKeyName = null;
							StringBuffer primaryKeyColumns = new StringBuffer();
							while (primaryKeys.next()) {
								String thisKeyName = primaryKeys.getString("PK_NAME");
								if ((thisKeyName != null && primaryKeyName == null)
										|| (thisKeyName == null && primaryKeyName != null)
										|| (thisKeyName != null && !thisKeyName
												.equals(primaryKeyName))
										|| (primaryKeyName != null && !primaryKeyName
												.equals(thisKeyName))) {
									// the keynames aren't the same, so output
									// all that we have so far (if anything)
									// and start a new primary key entry
									if (primaryKeyColumns.length() > 0) {
										// There's something to output
										result.append(",\n    PRIMARY KEY ");
										if (primaryKeyName != null) {
											result.append(primaryKeyName);
										}
										result.append("("
												+ primaryKeyColumns.toString()
												+ ")");
									}
									// Start again with the new name
									primaryKeyColumns = new StringBuffer();
									primaryKeyName = thisKeyName;
								}
								// Now append the column
								if (primaryKeyColumns.length() > 0) {
									primaryKeyColumns.append(", ");
								}
								primaryKeyColumns.append(primaryKeys
										.getString("COLUMN_NAME"));
							}
							if (primaryKeyColumns.length() > 0) {
								// There's something to output
								result.append(",\n    PRIMARY KEY ");
//								if (primaryKeyName != null) {
//									result.append(primaryKeyName);
//								}
								result.append("("
										+ primaryKeyColumns.toString() + ")");
							}
						} catch (SQLException e) {
							// NB you will get this exception with the JDBC-ODBC
							// link because it says
							// [Microsoft][ODBC Driver Manager] Driver does not
							// support this function
							System.err
									.println("Unable to get primary keys for table "
											+ tableName + " because " + e);
						} finally {
							try {
								if (null != primaryKeys)
									primaryKeys.close();
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
						result.append("\n);\n");
						//如果是oracle，则加上oracle建表注释
						if(dbConn.getClass().getName().toUpperCase().indexOf("ORACLE") > -1){
							//表注释
							result.append("comment on table " + tableName + "\nis '" + tableDesc + "';\n");
							//字段注释
							try {
								if (tableName.contains("/") || tableName.contains("$") || tableName.contains("=") || tableName.contains("BIN")) {
									continue;
									// tableName = "\"" + tableName + "\"";
								}
								tableMetaData = dbMetaData.getColumns(null, null,tableName, "%");
								boolean firstLine = true;
								StringBuffer columnNmaes = new StringBuffer("");
								while (tableMetaData.next()) {
									String columnName = tableMetaData.getString("COLUMN_NAME");
									String columndesc = tableMetaData.getString("REMARKS");
									if(columnNmaes.indexOf(columnName) > -1 )
										continue;
									
									if (firstLine) {
										firstLine = false;
									} else {
										result.append(";\n");
									}
									if(columndesc != "" && columndesc != null)
										result.append("comment on column " + tableName+ "." + columnName + "\nis '" + columndesc + "'");
									else
										result.append("comment on column " + tableName+ "." + columnName + "\nis null");
									columnNmaes.append(columnName);
								}
							} catch (Exception e) {
								e.printStackTrace();
							} finally {
								try {
									if (null != tableMetaData)
										tableMetaData.close();
									tableMetaData = null;
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
							result.append(";\n");
						}else if(dbConn.getClass().getName().toUpperCase().indexOf("SQLSERVER") > -1){
							//如果是sqlserver，加sqlserver的注释
							result.append("GO\n");
							String descfirst = "exec sp_addextendedproperty N'MS_Description', N'";
							String descsecond = "', N'user', N'dbo', N'table', N'";
							String descthird = "', N'column',N'";
							//字段注释
							try {
								if (tableName.contains("/") || tableName.contains("$") || tableName.contains("=") || tableName.contains("BIN")) {
									continue;
								}
								tableMetaData = dbMetaData.getColumns(null, null,tableName, "%");
								boolean firstLine = true;
								StringBuffer columnNmaes = new StringBuffer("");
								while (tableMetaData.next()) {
									String columnName = tableMetaData.getString("COLUMN_NAME");
									if(columnNmaes.indexOf(columnName) > -1 )
										continue;
									
									if (firstLine) {
										firstLine = false;
									} else {
										result.append("\n");
									}
									PreparedStatement stmt1 = null;
									ResultSet rsDesc = null;
									//查询当前表的当前列的说明
									stmt1 = dbConn.prepareStatement("SELECT cast(p.value as NCHAR(100)) FROM sys.extended_properties p,"
											+ "sys.columns c where p.major_id=OBJECT_ID('" + tableName.toUpperCase() + "') and c.name= '"
											+ columnName.toUpperCase() + "' and p.major_id=c.object_id and p.minor_id=c.column_id");

									rsDesc = stmt1.executeQuery();
									if(rsDesc.next()){
										String columndesc = rsDesc.getString(1);
										if(columndesc != "" && columndesc != null)
											result.append(descfirst + columndesc + descsecond + tableName + descthird + columnName + "'");
										columnNmaes.append(columnName);
									}
								}
							} catch (Exception e) {
								e.printStackTrace();
							} finally {
								try {
									if (null != tableMetaData)
										tableMetaData.close();
									tableMetaData = null;
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
							result.append("GO\n");
						}
						// Right, we have a table, so we can go and dump it,
						// 如果文件为空，则先创建文件
						if (null == bos) {
							bos = InfoLog.writeFileForBuf(outCatalogName, "",bos);
						}
						// 没有数据的表结构就不写了
						dumpTable(catalogName, dbConn, resultTb, tableName, outCatalogName, result, bos);
						bos = InfoLog.writeFileForBuf(outCatalogName, resultTb.toString(), bos);
						resultTb.delete(0, resultTb.length());
						result.delete(0, result.length());
						
						//记录已经导出过的sql
						exptables.append(tableName);
					}
				} while (rs.next());
			}
			return result.toString();
		} catch (SQLException e) {
			// To change body of catch statement use
			// Options | File Templates.
			e.printStackTrace();
		} finally {
			try {
				bos = InfoLog.writeFileForBuf(outCatalogName,
						resultTb.toString(), bos);
				if (null != bos) {
					try {
						bos.flush();
						bos.close();
					} catch (Exception e) {
					}
				}
				resultTb.delete(0, resultTb.length());
				if (null != rs)
					rs.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				if (null != dbConn)
					dbConn.close();
			} catch (Exception e) {
				e.printStackTrace();
			}

			// if(bUseGs)
			// f1.renameTo(new File(path + catalogName +
			// "_Ok.sql"));
			InfoLog.info(catalogName, ".", catalogName, "处理完毕");
		}
		return null;

	}
	
	/** dump this particular table to the string buffer */
	private static void dumpTable(String dbName, Connection dbConn,
			StringBuffer result, String tableName, String outCatalogName,
			StringBuffer resultTb, OutputStream bos) {
		ResultSet rs = null;
		PreparedStatement stmt = null;
		long lnCnt = 0;
		try {
			// First we output the create table stuff
			if(dbConn.getClass().getName().toUpperCase().indexOf("SQLSERVER") > -1){
				stmt = dbConn.prepareStatement("SELECT * FROM " + tableName);
			}else{
				stmt = dbConn.prepareStatement("SELECT * FROM " + tableName,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
			}
			rs = stmt.executeQuery();
			ResultSetMetaData metaData = rs.getMetaData();
			int columnCount = metaData.getColumnCount();
			
			// Now we can output the actual data
			result.append("\n\n-- Data for " + tableName + "\n");
			
			//获取记录条数
			stmt = dbConn.prepareStatement("SELECT count(*) FROM " + tableName);
			ResultSet rs1 =  stmt.executeQuery();
			rs1.next();
			int rowCount = rs1.getInt(1);
			
			while (rs.next()) {
				// 有数据就加上表头信息
				if (0L == lnCnt && 0 < resultTb.length()) {
					result.append(resultTb.toString());
					resultTb.delete(0, resultTb.length());
				}
				result.append("INSERT INTO " + tableName + " VALUES (");
				for (int i = 0; i < columnCount; i++) {
					if (i > 0) {
						result.append(", ");
					}
					Object value = rs.getObject(i + 1);
					if (value == null) {
						result.append("NULL");
					} else {
						ResultSet tableMetaData = null;
						try{
							DatabaseMetaData dbMetaData = dbConn.getMetaData();
							String columnNmae = metaData.getColumnName(i+1);
							tableMetaData = dbMetaData.getColumns(null, null,tableName, columnNmae);
							tableMetaData.next();
							String columntype = tableMetaData.getString("TYPE_NAME");
							//判断如果字段为oracle的date类型，则对value加上to_date处理
							if(columntype.equals("DATE") && dbConn.getClass().getName().toUpperCase().indexOf("ORACLE") > -1){
								String outputValue = value.toString();
								outputValue = outputValue.replaceAll("'", "\\'");
								if(outputValue.length() == 21){
									outputValue = outputValue.substring(0, outputValue.length()-2);
								}
								result.append("to_date('" + outputValue + "','YYYY-MM-DD HH24:MI:SS')");
							}else{
								String outputValue = value.toString();
								outputValue = outputValue.replaceAll("'", "\\'");
								result.append("'" + outputValue + "'");
							}
						}catch (Exception e) {
							e.printStackTrace();
						} finally {
							try {
								if (null != tableMetaData)
									tableMetaData.close();
								tableMetaData = null;
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
				result.append(");\n");
				lnCnt++;
				//每一千条执行提交
				if(dbConn.getClass().getName().toUpperCase().indexOf("SQLSERVER") < 0){
					if(lnCnt % 1000 == 0 && 0 < lnCnt){
						result.append("commit;\n");
					}else if(lnCnt == rowCount){//剩下的不满一千条的，再进行提交
						result.append("commit;\n");
					}
				}
				bos = InfoLog.writeFileForBuf(outCatalogName, result.toString(), bos);
				result.delete(0, result.length());
				if (0 == lnCnt % 10000 && 0 < lnCnt)
					InfoLog.info(dbName, ".", tableName, ": ", lnCnt / 10000, "万");
			}
		} catch (Exception e) {
			 System.err.println("导出表 " + tableName + " 失败，原因: " + e);
		} finally {
			try {
				if (null != rs)
					rs.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				if (null != stmt)
					stmt.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
			if (0 < lnCnt)
				InfoLog.info(dbName, ".", tableName, " 记录数：", lnCnt);
		}
	}

	public static void main(String[] args) {
		Map driverMap = new HashMap();
		driverMap.put("oracle", "oracle.jdbc.driver.OracleDriver");
		driverMap.put("sqlserver", "com.microsoft.sqlserver.jdbc.SQLServerDriver");
		driverMap.put("mysql", "com.mysql.jdbc.Driver");

		Map urlMap = new HashMap();
		urlMap.put("oracle", "jdbc:oracle:thin:@");
		urlMap.put("sqlserver", "jdbc:sqlserver://");
		urlMap.put("mysql", "jdbc:mysql://");
		
		Map portMap = new HashMap();
		portMap.put("oracle", "1521");
		portMap.put("sqlserver", "1433");
		portMap.put("mysql", "3306");
		
//		String oracleurl = "jdbc:oracle:thin:@192.168.24.18:1521/orcl";
//		String sqlserverurl = "jdbc:sqlserver://192.168.24.18:1433; DatabaseName=database";
//		String mysqlurl = "jdbc:mysql://192.168.24.18:3306/database";

//		String driver = "oracle.jdbc.driver.OracleDriver";
//		String url = "jdbc:oracle:thin:@192.168.24.18:1521/orcl";
//		String username = "yhomsmp";
//		String password = "yhomsmp";
//		String queryTable = "";
//		String type = "TABLE";
//		String expTable = "OMIM_PLAN";
		args = new String[6];
		args[0] = "sqlserver";
		args[1] = "localhost";
		args[2] = "testdb";
		args[3] = "test";
		args[4] = "test";
		args[5] = "a";
		
		String driver = "" + driverMap.get(args[0]);
		String url = "";
		if("sqlserver".equals(args[0])){
			url = urlMap.get(args[0]) + args[1] + ":" + portMap.get(args[0]) + ";DatabaseName=" + args[2];
		}else{
			url = urlMap.get(args[0]) + args[1] + ":" + portMap.get(args[0]) + "/" + args[2];
		}
		String username = args[3];
		String password = args[4];
		String queryTable = "";
		String type = "TABLE";
		String expTable = args[5];
		
		begainExp(driver, url, username, password, queryTable, type, expTable);
	}

	/** Main method takes arguments for connection to JDBC etc.
	 * 0 数据库驱动driver
	 * 1 数据库连接url
	 * 2 数据库用户名
	 * 3 数据库密码
	 * 4 查询数据库对象时的表名参数（好像只能传入一个）
	 * 5 查询数据库对象时的查询对象类型参数（类似TABLE,VIEW等）
	 * 6 需要导出数据的表，以逗号分隔
	 */
	public static void begainExp(final String... args) {
		MyThreadPoolExecutor.getInstance().addRunnable(new Runnable() {
			public void run() {
				try {
					Thread.sleep(333);
					Properties props = new Properties();
					try {
						if (4 <= args.length) {
							int i = 0;
							props.put("driver.class", args[i++]);
							props.put("driver.url", args[i++]);//需要导出数据的数据库地址
							props.put("schemaPattern", args[i].toUpperCase());//需要导出数据的用户
							props.put("user", args[i++]);//需要导出数据的用户
							props.put("password", args[i++]);//需要导出数据的用户密码
							props.put("tableName", args[i++]);//需要导出数据的对象名称
							props.put("type", args[i++]);//需要导出数据的数据库对象类型
							props.put("tablesname", args[i++].toUpperCase());//需要导出数据的数据库对象名称
						}
						if (0 < props.size())
							dumpDB(props);
						else
							System.err.println("导出数据失败，参数错误，请检查");
						props.clear();
					} catch (Exception e) {
						System.err.println("打开properties出错: " + args[0] + " exception: " + e);
					}
				} catch (Throwable e) {
					e.printStackTrace();
				}
			}
		});
	}
}
